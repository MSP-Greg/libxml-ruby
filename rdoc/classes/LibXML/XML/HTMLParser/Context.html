<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>LibXML::XML::HTMLParser::Context</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <link href='../../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>class</span>
          LibXML::XML::HTMLParser::Context
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../../../../files/ext/libxml/libxml_c.html">ext/libxml/libxml.c</a>
          </li>
        </ol>
        <div class='parent'>
          Superclass:
          <strong>cXMLParserContext</strong>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>The <a href="Context.html">XML::HTMLParser::Context</a> class provides
            in-depth control over how a document is parsed.</p>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Class</h3>
            <ol>
              <li><a target="docwin" href="#method-c-file">file</a></li>
              <li><a target="docwin" href="#method-c-io">io</a></li>
              <li><a target="docwin" href="#method-c-string">string</a></li>
            </ol>
            <h3>Public Instance</h3>
            <ol>
              <li><a target="docwin" href="#method-i-close">close</a></li>
              <li><a target="docwin" href="#method-i-disable_cdata-3D">disable_cdata=</a></li>
              <li><a target="docwin" href="#method-i-options-3D">options=</a></li>
            </ol>
          </div>
          <div id='context'>
          </div>
          <div id='section'>
            <div id='methods'>
              <h2>Public Class methods</h2>
              <div class='method public-class' id='method-method-c-file'>
                <a name='method-c-file'></a>
                <div class='synopsis'>
                  <span class='name'>
                    <div>XML::HTMLParser::Context.file(file) -> XML::HTMLParser::Context</div>
                  </span>
                </div>
                <div class='description'>
                  
                  <p>Creates a new parser context based on the specified file or uri.</p>
                  
                  <p>Parameters:</p>
                  
                  <pre>file - A filename or uri.</pre>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-file-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-file-source'>static VALUE rxml_html_parser_context_file(VALUE klass, VALUE file)&#x000A;{&#x000A;  htmlParserCtxtPtr ctxt = htmlCreateFileParserCtxt(StringValuePtr(file), NULL);&#x000A;  if (!ctxt)&#x000A;    rxml_raise(&amp;xmlLastError);&#x000A;&#x000A;  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and &#x000A;     xmlCtxtUseOptionsInternal (called below) initialize slightly different&#x000A;     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt&#x000A;     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */&#x000A;  htmlCtxtUseOptions(ctxt, rxml_libxml_default_options());&#x000A;&#x000A;  return rxml_html_parser_context_wrap(ctxt);&#x000A;}</pre>
                </div>
              </div>
              <div class='method public-class' id='method-method-c-io'>
                <a name='method-c-io'></a>
                <div class='synopsis'>
                  <span class='name'>
                    <div>XML::HTMLParser::Context.io(io) -> XML::HTMLParser::Context</div>
                  </span>
                </div>
                <div class='description'>
                  
                  <p>Creates a new parser context based on the specified io object.</p>
                  
                  <p>Parameters:</p>
                  
                  <pre>io - A ruby IO object.</pre>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-io-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-io-source'>static VALUE rxml_html_parser_context_io(VALUE klass, VALUE io)&#x000A;{&#x000A;  VALUE result;&#x000A;  htmlParserCtxtPtr ctxt;&#x000A;  xmlParserInputBufferPtr input;&#x000A;  xmlParserInputPtr stream;&#x000A;&#x000A;  if (NIL_P(io))&#x000A;    rb_raise(rb_eTypeError, &quot;Must pass in an IO object&quot;);&#x000A;&#x000A;  input = xmlParserInputBufferCreateIO((xmlInputReadCallback) rxml_read_callback, NULL,&#x000A;                                     (void*)io, XML_CHAR_ENCODING_NONE);&#x000A;&#x000A;  ctxt = htmlNewParserCtxt();&#x000A;  if (!ctxt)&#x000A;  {&#x000A;    xmlFreeParserInputBuffer(input);&#x000A;    rxml_raise(&amp;xmlLastError);&#x000A;  }&#x000A;&#x000A;  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and &#x000A;     xmlCtxtUseOptionsInternal (called below) initialize slightly different&#x000A;     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt&#x000A;     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */&#x000A;  htmlCtxtUseOptions(ctxt, rxml_libxml_default_options());&#x000A;&#x000A;  stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);&#x000A;&#x000A;  if (!stream)&#x000A;  {&#x000A;    xmlFreeParserInputBuffer(input);&#x000A;    xmlFreeParserCtxt(ctxt);&#x000A;    rxml_raise(&amp;xmlLastError);&#x000A;  }&#x000A;  inputPush(ctxt, stream);&#x000A;  result = rxml_html_parser_context_wrap(ctxt);&#x000A;&#x000A;  /* Attach io object to parser so it won&#39;t get freed.*/&#x000A;  rb_ivar_set(result, IO_ATTR, io);&#x000A;&#x000A;  return result;&#x000A;}</pre>
                </div>
              </div>
              <div class='method public-class' id='method-method-c-string'>
                <a name='method-c-string'></a>
                <div class='synopsis'>
                  <span class='name'>
                    <div>XML::HTMLParser::Context.string(string) -> XML::HTMLParser::Context</div>
                  </span>
                </div>
                <div class='description'>
                  
                  <p>Creates a new parser context based on the specified string.</p>
                  
                  <p>Parameters:</p>
                  
                  <pre>string - A string that contains the data to parse.</pre>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-string-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-string-source'>static VALUE rxml_html_parser_context_string(VALUE klass, VALUE string)&#x000A;{&#x000A;  htmlParserCtxtPtr ctxt;&#x000A;  Check_Type(string, T_STRING);&#x000A;&#x000A;  if (RSTRING_LEN(string) == 0)&#x000A;    rb_raise(rb_eArgError, &quot;Must specify a string with one or more characters&quot;);&#x000A;&#x000A;  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(string),&#x000A;                                   RSTRING_LEN(string));&#x000A;  if (!ctxt)&#x000A;    rxml_raise(&amp;xmlLastError);&#x000A;&#x000A;  /* This is annoying, but xmlInitParserCtxt (called indirectly above) and &#x000A;     xmlCtxtUseOptionsInternal (called below) initialize slightly different&#x000A;     context options, in particular XML_PARSE_NODICT which xmlInitParserCtxt&#x000A;     sets to 0 and xmlCtxtUseOptionsInternal sets to 1.  So we have to call both. */&#x000A;  htmlCtxtUseOptions(ctxt, rxml_libxml_default_options());&#x000A;&#x000A;  htmlDefaultSAXHandlerInit();&#x000A;  if (ctxt-&gt;sax != NULL)&#x000A;    memcpy(ctxt-&gt;sax, &amp;htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));&#x000A;  &#x000A;  return rxml_html_parser_context_wrap(ctxt);&#x000A;}</pre>
                </div>
              </div>
              <h2>Public Instance methods</h2>
              <div class='method public-instance' id='method-method-i-close'>
                <a name='method-i-close'></a>
                <div class='synopsis'>
                  <span class='name'>
                    <div>context.close -> nil</div>
                  </span>
                </div>
                <div class='description'>
                  
                  <p>Closes the underlying input streams.  This is useful when parsing a large
                  amount of files and you want to close the files without relying on
                  Ruby&#39;s garbage collector to run.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-close-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-close-source'>static VALUE rxml_html_parser_context_close(VALUE self)&#x000A;{&#x000A;  htmlParserCtxtPtr ctxt;&#x000A;  xmlParserInputPtr xinput;&#x000A;  Data_Get_Struct(self, htmlParserCtxt, ctxt);&#x000A;&#x000A;  while ((xinput = inputPop(ctxt)) != NULL)&#x000A;  {&#x000A;         xmlFreeInputStream(xinput);&#x000A;  }&#x000A;  return Qnil;&#x000A;}</pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-disable_cdata-3D'>
                <a name='method-i-disable_cdata-3D'></a>
                <div class='synopsis'>
                  <span class='name'>
                    <div>context.disable_cdata = (true|false)</div>
                  </span>
                </div>
                <div class='description'>
                  
                  <p>Control whether the CDATA nodes will be created in this context.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-disable_cdata-3D-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-disable_cdata-3D-source'>static VALUE rxml_html_parser_context_disable_cdata_set(VALUE self, VALUE bool)&#x000A;{&#x000A;  htmlParserCtxtPtr ctxt;&#x000A;  Data_Get_Struct(self, htmlParserCtxt, ctxt);&#x000A;&#x000A;  if (ctxt-&gt;sax == NULL)&#x000A;    rb_raise(rb_eRuntimeError, &quot;Sax handler is not yet set&quot;);&#x000A;&#x000A;  /* LibXML controls this internally with the default SAX handler. */ &#x000A;  if (bool)&#x000A;    ctxt-&gt;sax-&gt;cdataBlock = NULL;&#x000A;  else&#x000A;    ctxt-&gt;sax-&gt;cdataBlock = htmlDefaultSAXHandler.cdataBlock;&#x000A;&#x000A;  return bool;&#x000A;}</pre>
                </div>
              </div>
              <div class='method public-instance' id='method-method-i-options-3D'>
                <a name='method-i-options-3D'></a>
                <div class='synopsis'>
                  <span class='name'>
                    <div>context.options = XML::Parser::Options::NOENT |</div>
                    <div>XML::Parser::Options::NOCDATA</div>
                  </span>
                </div>
                <div class='description'>
                  
                  <p>Provides control over the execution of a parser.  Valid values  are the
                  constants defined on <a
                  href="../Parser/Options.html">XML::Parser::Options</a>.  Multiple options
                  can be combined by using Bitwise OR (|).</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-i-options-3D-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-i-options-3D-source'>static VALUE rxml_html_parser_context_options_set(VALUE self, VALUE options)&#x000A;{&#x000A;  int result;&#x000A;  int xml_options = NUM2INT(options);&#x000A;  htmlParserCtxtPtr ctxt;&#x000A;  Check_Type(options, T_FIXNUM);&#x000A;&#x000A;  Data_Get_Struct(self, htmlParserCtxt, ctxt);&#x000A;  result = htmlCtxtUseOptions(ctxt, xml_options);&#x000A;&#x000A;#if LIBXML_VERSION &gt;= 20707&#x000A;  /* Big hack here, but htmlCtxtUseOptions doens&#39;t support HTML_PARSE_NOIMPLIED.&#x000A;     So do it ourselves. There must be a better way??? */&#x000A;  if (xml_options &amp; HTML_PARSE_NOIMPLIED) &#x000A;  {&#x000A;          ctxt-&gt;options |= HTML_PARSE_NOIMPLIED;&#x000A;  }&#x000A;#endif&#x000A;&#x000A;  return self;&#x000A;}</pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
